# AP3216C

## 引脚接线
| AP3216C | 开发板 |
| --- | --- |
| SCL | i2c1_scl |
| SDA | i2c1_sda |
| INT | GPIO1_IO04 |
| VCC | 3.3V |
| VLED | 3.3V |
| GND | GND |

## 数据读取方式
之前没写过需要读数据的传感器的驱动, 这里就以AP3216C为例, 分析一下如何读取数据.

读取数据我觉得有2种方式:

1.轮询方式: 轮询的方式就是在驱动层提供`read()`接口,然后应用层不断调用这个接口读取数据

2.中断方式: 中断的方式就是在驱动层注册一个中断,并且要使用传感器模块的INT引脚,一般大部分传感器都会有该引脚,当数据准备好了之后就会在该引脚产生一个下降沿,驱动层就会触发中断,然后在中断下半部读取数据,并清除中断标志位,这样应用层就可以读取到数据了.
但是有的时候数据还没准备好(新的中断还没来)应用层就去读数据了,所以驱动还需要注意这部分的处理,最好封装个`poll()`接口,让应用层可以判断数据是否准备好.

或者可以引入**异步通知**机制,当数据准备好了,驱动层主动通知应用层,应用层再读取数据.Linux中常见的异步通知机制就是**信号**.信号可以看成软件层面的中断

关于到底选择哪些方式, 其实都可以, 取决于应用层的需求.
- 如果我需要每个时刻都有数据, 那么就直接在应用层轮训读取就好了
- 如果我只需要有效的数据(比如超过设定阈值),或者不希望得到的数据是重复的(传感器的采样率低于读取频率),那么就用中断驱动的方式

## 注意事项
- INT引脚默认被模块上拉了, 触发中断时, 引脚出现下降沿
- 必须要清除中断标志位, 才能再次触发中断(INT再次触发下降沿)
- 触发中断有个阈值, 超过这个阈值才会触发中断, 这个阈值可以通过寄存器设置(大部分博客都没写, 但用户手册上有)
- 读取数据不能在中断上半部、soft irq、tasklet中运行, 因为`i2c_transfer()`会阻塞线程,所以只能用`work queue`来读

## 参考链接
- https://blog.csdn.net/mftang/article/details/136222319
- https://blog.csdn.net/zhengnianli/article/details/115222723
- https://www.cnblogs.com/burnk/p/17489068.html